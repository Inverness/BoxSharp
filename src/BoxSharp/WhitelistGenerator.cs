using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace BoxSharp
{
    /// <summary>
    /// Allows whitelists to be generated by examining assembly metadata.
    /// 
    /// This is useful for library users who would like to generate whitelist files from known types, and
    /// then remove any symbols that will not be allowed.
    /// </summary>
    public sealed class WhitelistGenerator
    {
        private readonly Dictionary<string, Type> _types = new();

        public void AddType(Type type)
        {
            if (type.IsConstructedGenericType)
                throw new ArgumentException("Must specify a generic type definition");
            _types[NormalizeTypeName(type.FullName)] = type;
        }

        public IEnumerable<WhitelistSymbol> GetWhitelistSymbols()
        {
            List<string> paths = _types.Values.Select(t => t.Assembly)
                                              .Distinct()
                                              .Select(a => a.Location)
                                              .Where(l => !string.IsNullOrEmpty(l))
                                              .ToList();

            List<PortableExecutableReference> refs = paths.Select(p => MetadataReference.CreateFromFile(p)).ToList();

            CSharpCompilation compilation = CSharpCompilation.Create(null, null, refs, null);

            foreach (INamedTypeSymbol namedType in GetNamedTypeSymbols(compilation))
            {
                if (namedType.DeclaredAccessibility != Accessibility.Public)
                    continue;

                string fullName = GetFullName(namedType);

                if (!_types.ContainsKey(fullName))
                    continue;

                string decId = DocumentationCommentId.CreateDeclarationId(namedType);

                yield return new WhitelistSymbol(decId, false);

                foreach (ISymbol member in namedType.GetMembers())
                {
                    if (member.DeclaredAccessibility != Accessibility.Public &&
                        member.DeclaredAccessibility != Accessibility.Protected &&
                        member.DeclaredAccessibility != Accessibility.ProtectedOrInternal)
                        continue;

                    bool validKind;

                    switch (member.Kind)
                    {
                        case SymbolKind.Method:
                            validKind = !IsHiddenMethodKind(((IMethodSymbol) member).MethodKind);
                            break;
                        case SymbolKind.Field:
                        case SymbolKind.Property:
                        case SymbolKind.Event:
                            validKind = true;
                            break;
                        default:
                            validKind = false;
                            break;
                    }

                    if (!validKind)
                        continue;

                    string memDecId = DocumentationCommentId.CreateDeclarationId(member);

                    yield return new WhitelistSymbol(memDecId, false);
                }
            }
        }

        private static bool IsHiddenMethodKind(MethodKind kind)
        {
            switch (kind)
            {
                case MethodKind.EventAdd:
                case MethodKind.EventRemove:
                case MethodKind.PropertyGet:
                case MethodKind.PropertySet:
                    return true;
                default:
                    return false;
            }
        }

        private static string NormalizeTypeName(string name)
        {
            return name.Replace("+", ".");
        }

        private static string GetFullName(INamedTypeSymbol type)
        {
            var sb = new StringBuilder();

            AppendName(sb, type);

            return sb.ToString();
        }

        private static void AppendName(StringBuilder sb, INamespaceOrTypeSymbol type)
        {
            if (type.ContainingSymbol is INamespaceOrTypeSymbol nst && nst.CanBeReferencedByName)
            {
                AppendName(sb, nst);
                sb.Append('.');
            }
            sb.Append(type.MetadataName);
        }

        private static IEnumerable<INamedTypeSymbol> GetNamedTypeSymbols(Compilation compilation)
        {
            var stack = new Stack<INamespaceOrTypeSymbol>();
            stack.Push(compilation.GlobalNamespace);

            while (stack.Count > 0)
            {
                INamespaceOrTypeSymbol symbol = stack.Pop();

                if (symbol is INamedTypeSymbol namedType)
                {
                    yield return namedType;
                }

                foreach (ISymbol member in symbol.GetMembers())
                {
                    if (member is INamespaceOrTypeSymbol nsOrType)
                    {
                        stack.Push(nsOrType);
                    }
                }
            }
        }
    }
}
